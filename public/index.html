<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OptiFocus - Photo Capture System</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: system-ui, -apple-system, sans-serif; 
      background: #1a1a1a; 
      color: #fff;
    }
    .container { 
      max-width: 1400px; 
      margin: 0 auto; 
      padding: 20px; 
    }
    h1 { 
      text-align: center; 
      margin-bottom: 20px; 
      color: #4CAF50;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      background: #2a2a2a;
      padding: 10px;
      border-radius: 8px;
    }
    .tab {
      padding: 12px 24px;
      background: #3a3a3a;
      border: 2px solid #555;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
    }
    .tab:hover { background: #4a4a4a; }
    .tab.active { 
      background: #4CAF50; 
      border-color: #4CAF50;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }
    button:hover { background: #45a049; }
    button:disabled { 
      background: #666; 
      cursor: not-allowed;
    }
    button.secondary {
      background: #2196F3;
    }
    button.secondary:hover {
      background: #0b7dda;
    }
    button.danger {
      background: #f44336;
    }
    button.danger:hover {
      background: #da190b;
    }
    #viewport {
      position: relative;
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      background: #000;
      border: 2px solid #4CAF50;
      border-radius: 8px;
      overflow: hidden;
    }
    video, canvas, #capturedImg {
      display: block;
      width: 100%;
      height: auto;
    }
    video {
      position: absolute;
      top: 0;
      left: 0;
    }
    canvas {
      position: relative;
      z-index: 1;
      cursor: crosshair;
    }
    #capturedImg {
      position: absolute;
      top: 0;
      left: 0;
      display: none;
      z-index: 0;
    }
    #log {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 6px;
      margin-top: 20px;
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .instructions {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 15px;
      border-left: 4px solid #4CAF50;
    }
    .instructions h3 {
      margin-bottom: 8px;
      color: #4CAF50;
    }
    .instructions ul {
      margin-left: 20px;
      line-height: 1.8;
    }
    .stable-indicator {
      background: #2a2a2a;
      padding: 10px 15px;
      border-radius: 6px;
      margin-bottom: 15px;
      text-align: center;
      font-weight: 600;
      border: 2px solid #666;
    }
    .stable-indicator.stable {
      background: #1b5e20;
      border-color: #4CAF50;
      color: #4CAF50;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>OptiFocus - Photo Capture Measurement System</h1>
    
    <div class="tabs">
      <div class="tab active" data-tab="pupil">Pupil Detector</div>
      <div class="tab" data-tab="frame">Frame Fitter</div>
    </div>

    <div id="pupil-tab" class="tab-content active">
      <div class="instructions">
        <h3>Pupil Detection Instructions</h3>
        <ul>
          <li>Position at arm's length (60-75cm) from camera</li>
          <li>Look at the camera center</li>
          <li>Keep head straight</li>
          <li>Wait for "STABLE" indicator</li>
          <li>Click "Capture Photo" to freeze the image</li>
          <li>Then drag the green pupil crosses to adjust position</li>
          <li>Click "Save Result" to download measurement</li>
        </ul>
      </div>
      
      <div class="stable-indicator" id="pupil-stable">
        Waiting for stable position...
      </div>

      <div class="controls">
        <button id="start-pupil">Start Camera</button>
        <button id="capture-photo-pupil" class="secondary" disabled>Capture Photo</button>
        <button id="reset-auto">Reset Manual (R)</button>
        <button id="save-pupil" class="danger" disabled>Save Result</button>
        <button id="stop-pupil">Stop</button>
      </div>
    </div>

    <div id="frame-tab" class="tab-content">
      <div class="instructions">
        <h3>Frame Fitting Instructions</h3>
        <ul>
          <li>Wear your glasses/spectacles</li>
          <li>Position at arm's length from camera</li>
          <li>Keep head straight</li>
          <li>Wait for "STABLE" indicator</li>
          <li>Click "Capture Photo" to freeze the image</li>
          <li>Then drag the green corner handles to match frame edges</li>
          <li>Both frames are green - the active frame is brighter</li>
          <li>Toggle between frames to adjust both lenses</li>
        </ul>
      </div>
      
      <div class="stable-indicator" id="frame-stable">
        Waiting for stable position...
      </div>
      
      <div class="controls">
        <button id="start-frame">Start Camera</button>
        <button id="capture-photo-frame" class="secondary" disabled>Capture Photo</button>
        <button id="toggle-frame" disabled>Toggle Frame (Left)</button>
        <button id="reset-frame">Reset Lines</button>
        <button id="save-frame" class="danger" disabled>Save Result</button>
        <button id="stop-frame">Stop</button>
      </div>
    </div>

    <div id="viewport">
      <video id="video" autoplay playsinline muted></video>
      <img id="capturedImg" />
      <canvas id="overlay"></canvas>
    </div>

    <h3 style="margin-top: 20px;">Measurement Log</h3>
    <pre id="log"></pre>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
  <script>
    const state = {
      currentTab: 'pupil',
      running: false,
      faceMesh: null,
      animationId: null,
      photoMode: false,
      capturedImage: null,
      capturedLandmarks: null,
      isStable: false,
      stabilityCounter: 0,
      lastMeasurement: null
    };

    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const capturedImg = document.getElementById('capturedImg');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');

    const W = 960, H = 720;
    canvas.width = W;
    canvas.height = H;

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tabName}-tab`).classList.add('active');
        state.currentTab = tabName;
        
        if (state.running) {
          stopCamera();
        }
      });
    });

    // ==================== PUPIL DETECTOR ====================
    const pupilDetector = {
      LEFT_EYE_IDX: [362, 385, 387, 263, 373, 386],
      RIGHT_EYE_IDX: [33, 160, 158, 133, 153, 159],
      LEFT_IRIS_INDICES: [468, 469, 470, 471, 472], // Center and 4 edge points
      RIGHT_IRIS_INDICES: [473, 474, 475, 476, 477], // Center and 4 edge points
      IRIS_REAL_MM: 11.7,
      FOCAL_PX: 850,
      HEAD_TILT_LIMIT_DEG: 6.0,
      STABILITY_THRESHOLD: 30,

      manualLeftPupil: null,
      manualRightPupil: null,
      autoLeftPupil: null,
      autoRightPupil: null,
      selectedEye: null,
      isDragging: false,

      dist(a, b) {
        if (!a || !b) return 0;
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      },

      // Calculate accurate pupil center using all iris landmarks
      calculatePupilCenter(lm, irisIndices) {
        // Use all 5 iris points for better accuracy
        const points = irisIndices.map(idx => [lm[idx].x * W, lm[idx].y * H]);
        
        // Weighted average: center point has more weight
        const centerPoint = points[0]; // Index 0 is the center
        const edgePoints = points.slice(1); // Remaining are edge points
        
        // Calculate centroid of edge points
        let sumX = centerPoint[0] * 3; // Give center 3x weight
        let sumY = centerPoint[1] * 3;
        
        edgePoints.forEach(p => {
          sumX += p[0];
          sumY += p[1];
        });
        
        const totalWeight = 3 + edgePoints.length;
        return [sumX / totalWeight, sumY / totalWeight];
      },

      // Validate pupil detection quality
      validatePupilDetection(lm, leftPupil, rightPupil) {
        // Check 1: Pupils should be roughly horizontally aligned
        const verticalDiff = Math.abs(leftPupil[1] - rightPupil[1]);
        const horizontalDist = Math.abs(leftPupil[0] - rightPupil[0]);
        
        if (verticalDiff > horizontalDist * 0.15) {
          return false; // Too much vertical misalignment
        }
        
        // Check 2: Distance between pupils should be reasonable (40-80mm equivalent)
        const pixelDist = this.dist(leftPupil, rightPupil);
        if (pixelDist < 40 || pixelDist > 200) {
          return false; // Unrealistic interpupillary distance
        }
        
        // Check 3: Pupils should be within eye boundaries
        const leftEyeCenter = [lm[468].x * W, lm[468].y * H];
        const rightEyeCenter = [lm[473].x * W, lm[473].y * H];
        
        // Left pupil should be near left eye center
        if (this.dist(leftPupil, leftEyeCenter) > 30) {
          return false;
        }
        
        // Right pupil should be near right eye center
        if (this.dist(rightPupil, rightEyeCenter) > 30) {
          return false;
        }
        
        return true;
      },

      ear(lm, idx, w, h) {
        const pts = idx.map(i => [lm[i].x * w, lm[i].y * h]);
        if (pts.length !== 6) return 0;
        const A = this.dist(pts[1], pts[5]);
        const B = this.dist(pts[2], pts[4]);
        const C = this.dist(pts[0], pts[3]);
        return C > 0 ? (A + B) / (2 * C) : 0;
      },

      processLiveView(lm) {
        // Calculate accurate pupil positions using all iris landmarks
        this.autoLeftPupil = this.calculatePupilCenter(lm, this.LEFT_IRIS_INDICES);
        this.autoRightPupil = this.calculatePupilCenter(lm, this.RIGHT_IRIS_INDICES);

        // Validate detection
        const isValid = this.validatePupilDetection(lm, this.autoLeftPupil, this.autoRightPupil);

        const finalLeft = this.autoLeftPupil;
        const finalRight = this.autoRightPupil;

        // Eye closure detection
        const earLeft = this.ear(lm, this.LEFT_EYE_IDX, W, H);
        const earRight = this.ear(lm, this.RIGHT_EYE_IDX, W, H);
        const leftOpen = earLeft > 0.20;
        const rightOpen = earRight > 0.20;

        // Calculate head tilt
        let headTiltDeg = 0;
        if (finalLeft && finalRight) {
          headTiltDeg = Math.atan2(finalRight[1] - finalLeft[1], finalRight[0] - finalLeft[0]) * 180 / Math.PI;
        }

        const tiltOk = Math.abs(headTiltDeg) <= this.HEAD_TILT_LIMIT_DEG;

        // Check alignment
        const noseCenter = [lm[1].x * W, lm[1].y * H];
        const center = [W / 2, H / 2];
        const axisX = W * 0.23, axisY = H * 0.40;
        const dx = (noseCenter[0] - center[0]) / axisX;
        const dy = (noseCenter[1] - center[1]) / axisY;
        const alignment = tiltOk && leftOpen && rightOpen && isValid && (dx * dx + dy * dy <= 1.0);

        // Stability detection
        if (alignment) {
          state.stabilityCounter++;
          if (state.stabilityCounter >= this.STABILITY_THRESHOLD) {
            state.isStable = true;
          }
        } else {
          state.stabilityCounter = 0;
          state.isStable = false;
        }

        // Update UI
        const stableIndicator = document.getElementById('pupil-stable');
        if (state.isStable) {
          stableIndicator.textContent = '✓ STABLE - Ready to capture';
          stableIndicator.classList.add('stable');
          document.getElementById('capture-photo-pupil').disabled = false;
        } else {
          let statusMsg = `Stabilizing... (${state.stabilityCounter}/${this.STABILITY_THRESHOLD})`;
          if (!isValid) statusMsg = 'Adjusting detection accuracy...';
          if (!leftOpen || !rightOpen) statusMsg = 'Keep both eyes open';
          if (!tiltOk) statusMsg = 'Straighten your head';
          
          stableIndicator.textContent = statusMsg;
          stableIndicator.classList.remove('stable');
          document.getElementById('capture-photo-pupil').disabled = true;
        }

        this.drawLiveView(center, axisX, axisY, alignment, isValid);
      },

      drawLiveView(ctr, axX, axY, aligned, isValid) {
        ctx.clearRect(0, 0, W, H);
        
        const col = aligned && isValid ? [0, 220, 0] : [130, 190, 255];
        
        // Alignment oval
        ctx.strokeStyle = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 0.9)`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.ellipse(ctr[0], ctr[1], axX, axY, 0, 0, Math.PI * 2);
        ctx.stroke();

        if (aligned && isValid) {
          ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
          ctx.beginPath();
          ctx.ellipse(ctr[0], ctr[1], axX, axY, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Accuracy indicator
        ctx.fillStyle = isValid ? 'rgba(0, 255, 0, 0.95)' : 'rgba(255, 165, 0, 0.95)';
        ctx.font = 'bold 14px system-ui';
        ctx.fillText(isValid ? '✓ High Accuracy' : '⚠ Adjusting...', W/2 - 60, 30);

        ctx.fillStyle = 'rgba(180, 180, 180, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText('Keep stable to enable capture', W/2 - 100, H - 20);
      },

      processPhotoMode(lm) {
        // Recalculate accurate pupil positions
        const detectedLeft = this.calculatePupilCenter(lm, this.LEFT_IRIS_INDICES);
        const detectedRight = this.calculatePupilCenter(lm, this.RIGHT_IRIS_INDICES);
        
        // Use manual positions if set, otherwise use accurate detected positions
        const finalLeft = this.manualLeftPupil || detectedLeft;
        const finalRight = this.manualRightPupil || detectedRight;

        // Calculate measurements
        const leftIrisPx = this.dist([lm[469].x * W, lm[469].y * H], [lm[471].x * W, lm[471].y * H]);
        const rightIrisPx = this.dist([lm[474].x * W, lm[474].y * H], [lm[476].x * W, lm[476].y * H]);
        const irisPx = (leftIrisPx + rightIrisPx) / 2;
        const scaleToUse = irisPx > 0 ? this.IRIS_REAL_MM / irisPx : 0.1;

        // PD calculation
        const ipdMm = this.dist(finalLeft, finalRight) * scaleToUse;

        // Nose line for eye-to-nose distance
        const noseCenter = [lm[1].x * W, lm[1].y * H];
        const eyeLineY = (finalLeft[1] + finalRight[1]) / 2;
        const noseLinePoint = [noseCenter[0], eyeLineY];

        const leftNoseMm = this.dist(finalLeft, noseLinePoint) * scaleToUse;
        const rightNoseMm = this.dist(finalRight, noseLinePoint) * scaleToUse;

        const headTiltDeg = Math.atan2(finalRight[1] - finalLeft[1], finalRight[0] - finalLeft[0]) * 180 / Math.PI;
        const distanceMm = irisPx > 0 ? Math.round((this.IRIS_REAL_MM * this.FOCAL_PX) / irisPx) : null;

        // Validate accuracy
        const isAccurate = this.validatePupilDetection(lm, finalLeft, finalRight);

        state.lastMeasurement = {
          pd: Math.round(ipdMm),
          leftNose: Math.round(leftNoseMm),
          rightNose: Math.round(rightNoseMm),
          tilt: Math.round(headTiltDeg),
          distance: distanceMm,
          accuracy: isAccurate ? 'High' : 'Medium'
        };

        this.drawPhotoMode(finalLeft, finalRight, noseLinePoint, ipdMm, leftNoseMm, rightNoseMm, headTiltDeg, distanceMm, isAccurate);
        
        log(`PD: ${Math.round(ipdMm)} mm | L→N: ${Math.round(leftNoseMm)} mm | R→N: ${Math.round(rightNoseMm)} mm | Accuracy: ${isAccurate ? 'High' : 'Medium'}`);
      },

      drawPhotoMode(fL, fR, nose, pd, lNose, rNose, tilt, dist, isAccurate) {
        ctx.clearRect(0, 0, W, H);

        // Nose line marker
        if (nose) {
          ctx.strokeStyle = 'rgba(255,255,0,0.8)';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(0, nose[1]);
          ctx.lineTo(W, nose[1]);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // PUPIL CROSS MARKERS with accuracy indicator
        const crossColor = isAccurate ? '#00ff00' : '#ffaa00';
        ctx.strokeStyle = crossColor;
        ctx.lineWidth = 3;
        const crossSize = 12;
        
        if (fL) {
          ctx.beginPath();
          ctx.moveTo(fL[0] - crossSize, fL[1]);
          ctx.lineTo(fL[0] + crossSize, fL[1]);
          ctx.moveTo(fL[0], fL[1] - crossSize);
          ctx.lineTo(fL[0], fL[1] + crossSize);
          ctx.stroke();
          
          // Circle around pupil
          ctx.beginPath();
          ctx.arc(fL[0], fL[1], 20, 0, Math.PI * 2);
          ctx.stroke();
          
          // Accuracy dot
          ctx.fillStyle = crossColor;
          ctx.beginPath();
          ctx.arc(fL[0], fL[1], 3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        if (fR) {
          ctx.beginPath();
          ctx.moveTo(fR[0] - crossSize, fR[1]);
          ctx.lineTo(fR[0] + crossSize, fR[1]);
          ctx.moveTo(fR[0], fR[1] - crossSize);
          ctx.lineTo(fR[0], fR[1] + crossSize);
          ctx.stroke();
          
          // Circle around pupil
          ctx.beginPath();
          ctx.arc(fR[0], fR[1], 20, 0, Math.PI * 2);
          ctx.stroke();
          
          // Accuracy dot
          ctx.fillStyle = crossColor;
          ctx.beginPath();
          ctx.arc(fR[0], fR[1], 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Line connecting pupils
        if (fL && fR) {
          ctx.strokeStyle = 'rgba(255,0,0,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(fL[0], fL[1]);
          ctx.lineTo(fR[0], fR[1]);
          ctx.stroke();
        }

        // Accuracy indicator
        ctx.fillStyle = isAccurate ? 'rgba(0, 255, 0, 0.95)' : 'rgba(255, 165, 0, 0.95)';
        ctx.font = 'bold 14px system-ui';
        ctx.fillText(isAccurate ? '✓ High Accuracy Detection' : '⚠ Medium Accuracy - Consider Manual Adjustment', 20, H - 45);

        // Manual status indicator
        const man = [];
        if (this.manualLeftPupil) man.push("L");
        if (this.manualRightPupil) man.push("R");
        if (man.length) {
          ctx.fillStyle = '#ffff00';
          ctx.font = 'bold 14px system-ui';
          ctx.fillText("Manual Adjusted: " + man.join(","), W - 180, 30);
        }

        // Measurements display
        ctx.fillStyle = 'rgba(255,255,0,0.95)';
        ctx.font = 'bold 20px system-ui';
        ctx.fillText(`PD: ${Math.round(pd)} mm`, 20, 35);
        
        ctx.font = '16px system-ui';
        ctx.fillText(`Left→Nose: ${Math.round(lNose)} mm`, 20, 65);
        ctx.fillText(`Right→Nose: ${Math.round(rNose)} mm`, 20, 90);
        ctx.fillText(`Tilt: ${Math.round(tilt)}°`, 20, 115);
        if (dist) {
          ctx.fillText(`Distance: ${dist} mm`, 20, 140);
        }

        // Instructions at bottom
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText('Drag the green crosses to adjust pupil positions | Press R to reset', 20, H - 20);
      },

      reset() {
        this.manualLeftPupil = null;
        this.manualRightPupil = null;
      }
    };

    // ==================== FRAME FITTER ====================
    const frameFitter = {
      landmarks: null,
      pixelsPerMm: null,
      leftFrame: { top: null, bottom: null, left: null, right: null },
      rightFrame: { top: null, bottom: null, left: null, right: null },
      activeFrame: 'left',
      dragging: null,
      dragOffset: [0, 0],
      STABILITY_THRESHOLD: 30,

      dist(a, b) {
        if (!a || !b) return 0;
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      },

      processLiveView(lm) {
        // Calibrate using IPD
        if (!this.pixelsPerMm) {
          const lIn = [lm[133].x * W, lm[133].y * H];
          const rIn = [lm[362].x * W, lm[362].y * H];
          const ipdPx = this.dist(lIn, rIn);
          if (ipdPx > 0) {
            this.pixelsPerMm = ipdPx / 63.0;
          }
        }

        // Stability detection
        if (this.pixelsPerMm) {
          state.stabilityCounter++;
          if (state.stabilityCounter >= this.STABILITY_THRESHOLD) {
            state.isStable = true;
          }
        } else {
          state.stabilityCounter = 0;
          state.isStable = false;
        }

        // Update UI
        const stableIndicator = document.getElementById('frame-stable');
        if (state.isStable) {
          stableIndicator.textContent = '✓ STABLE - Ready to capture';
          stableIndicator.classList.add('stable');
          document.getElementById('capture-photo-frame').disabled = false;
        } else {
          stableIndicator.textContent = `Stabilizing... (${state.stabilityCounter}/${this.STABILITY_THRESHOLD})`;
          stableIndicator.classList.remove('stable');
          document.getElementById('capture-photo-frame').disabled = true;
        }

        this.drawLiveView();
      },

      drawLiveView() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = 'rgba(180, 180, 180, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText('Keep stable to enable capture', W/2 - 100, H - 20);
      },

      initLines(lm) {
        const lBrow = [lm[70].x * W, lm[70].y * H];
        const rBrow = [lm[300].x * W, lm[300].y * H];
        const lOut = [lm[33].x * W, lm[33].y * H];
        const rOut = [lm[263].x * W, lm[263].y * H];
        const lCheek = [lm[205].x * W, lm[205].y * H];
        const rCheek = [lm[425].x * W, lm[425].y * H];
        const noseCenter = [lm[1].x * W, lm[1].y * H];

        const topY = Math.min(lBrow[1], rBrow[1]) - 20;
        const botY = Math.max(lCheek[1], rCheek[1]) - 30;
        
        // Reduce frame width by 30% from original
        const frameWidth = 50; // Fixed narrow width in pixels
        const frameHeight = botY - topY;

        // Left eye center
        const leftEyeCenter = [lm[468].x * W, lm[468].y * H];
        // Right eye center
        const rightEyeCenter = [lm[473].x * W, lm[473].y * H];

        // Left frame (green) - centered on left eye
        this.leftFrame.top = { x1: leftEyeCenter[0] - frameWidth/2, y1: topY, x2: leftEyeCenter[0] + frameWidth/2, y2: topY };
        this.leftFrame.bottom = { x1: leftEyeCenter[0] - frameWidth/2, y1: botY, x2: leftEyeCenter[0] + frameWidth/2, y2: botY };
        this.leftFrame.left = { x1: leftEyeCenter[0] - frameWidth/2, y1: topY, x2: leftEyeCenter[0] - frameWidth/2, y2: botY };
        this.leftFrame.right = { x1: leftEyeCenter[0] + frameWidth/2, y1: topY, x2: leftEyeCenter[0] + frameWidth/2, y2: botY };

        // Right frame (green) - same size as left, centered on right eye
        this.rightFrame.top = { x1: rightEyeCenter[0] - frameWidth/2, y1: topY, x2: rightEyeCenter[0] + frameWidth/2, y2: topY };
        this.rightFrame.bottom = { x1: rightEyeCenter[0] - frameWidth/2, y1: botY, x2: rightEyeCenter[0] + frameWidth/2, y2: botY };
        this.rightFrame.left = { x1: rightEyeCenter[0] - frameWidth/2, y1: topY, x2: rightEyeCenter[0] - frameWidth/2, y2: botY };
        this.rightFrame.right = { x1: rightEyeCenter[0] + frameWidth/2, y1: topY, x2: rightEyeCenter[0] + frameWidth/2, y2: botY };

        log('Frame lines initialized (narrow equal frames) - drag corners to adjust');
      },

      processPhotoMode(lm) {
        // Initialize lines if not set
        if (!this.leftFrame.top) {
          this.initLines(lm);
        }

        this.drawPhotoMode();
      },

      drawPhotoMode() {
        ctx.clearRect(0, 0, W, H);

        if (!this.leftFrame.top) return;

        // Draw BOTH frames in green with FULL OPACITY (both fully visible and movable)
        
        // Determine which is active
        const isLeftActive = this.activeFrame === 'left';
        
        // Draw LEFT frame
        ctx.strokeStyle = isLeftActive ? '#00ff00' : '#00ff00';
        ctx.lineWidth = isLeftActive ? 3 : 3;
        ctx.beginPath();
        ctx.moveTo(this.leftFrame.top.x1, this.leftFrame.top.y1);
        ctx.lineTo(this.leftFrame.top.x2, this.leftFrame.top.y2);
        ctx.lineTo(this.leftFrame.right.x2, this.leftFrame.right.y2);
        ctx.lineTo(this.leftFrame.bottom.x2, this.leftFrame.bottom.y2);
        ctx.lineTo(this.leftFrame.bottom.x1, this.leftFrame.bottom.y1);
        ctx.lineTo(this.leftFrame.left.x1, this.leftFrame.left.y1);
        ctx.closePath();
        ctx.stroke();

        // Draw left frame corner handles
        ctx.fillStyle = isLeftActive ? '#00ff00' : 'rgba(0, 255, 0, 0.6)';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        
        const leftHandles = [
          [this.leftFrame.top.x1, this.leftFrame.top.y1],
          [this.leftFrame.top.x2, this.leftFrame.top.y2],
          [this.leftFrame.bottom.x1, this.leftFrame.bottom.y1],
          [this.leftFrame.bottom.x2, this.leftFrame.bottom.y2]
        ];
        
        leftHandles.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        });

        // Draw RIGHT frame
        ctx.strokeStyle = !isLeftActive ? '#00ff00' : '#00ff00';
        ctx.lineWidth = !isLeftActive ? 3 : 3;
        ctx.beginPath();
        ctx.moveTo(this.rightFrame.top.x1, this.rightFrame.top.y1);
        ctx.lineTo(this.rightFrame.top.x2, this.rightFrame.top.y2);
        ctx.lineTo(this.rightFrame.right.x2, this.rightFrame.right.y2);
        ctx.lineTo(this.rightFrame.bottom.x2, this.rightFrame.bottom.y2);
        ctx.lineTo(this.rightFrame.bottom.x1, this.rightFrame.bottom.y1);
        ctx.lineTo(this.rightFrame.left.x1, this.rightFrame.left.y1);
        ctx.closePath();
        ctx.stroke();

        // Draw right frame corner handles
        ctx.fillStyle = !isLeftActive ? '#00ff00' : 'rgba(0, 255, 0, 0.6)';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        
        const rightHandles = [
          [this.rightFrame.top.x1, this.rightFrame.top.y1],
          [this.rightFrame.top.x2, this.rightFrame.top.y2],
          [this.rightFrame.bottom.x1, this.rightFrame.bottom.y1],
          [this.rightFrame.bottom.x2, this.rightFrame.bottom.y2]
        ];
        
        rightHandles.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        });

        // Calculate and display measurements
        if (this.pixelsPerMm) {
          const leftWidth = this.dist(
            [this.leftFrame.top.x1, this.leftFrame.top.y1], 
            [this.leftFrame.top.x2, this.leftFrame.top.y2]
          ) / this.pixelsPerMm;
          
          const leftHeight = this.dist(
            [this.leftFrame.left.x1, this.leftFrame.left.y1], 
            [this.leftFrame.left.x2, this.leftFrame.left.y2]
          ) / this.pixelsPerMm;
          
          const rightWidth = this.dist(
            [this.rightFrame.top.x1, this.rightFrame.top.y1], 
            [this.rightFrame.top.x2, this.rightFrame.top.y2]
          ) / this.pixelsPerMm;
          
          const rightHeight = this.dist(
            [this.rightFrame.left.x1, this.rightFrame.left.y1], 
            [this.rightFrame.left.x2, this.rightFrame.left.y2]
          ) / this.pixelsPerMm;
          
          const bridgeW = this.dist(
            [this.leftFrame.right.x1, (this.leftFrame.right.y1 + this.leftFrame.right.y2) / 2],
            [this.rightFrame.left.x1, (this.rightFrame.left.y1 + this.rightFrame.left.y2) / 2]
          ) / this.pixelsPerMm;

          ctx.fillStyle = 'rgba(255,255,0,0.95)';
          ctx.font = 'bold 20px system-ui';
          ctx.fillText(`Left: ${Math.round(leftWidth)}×${Math.round(leftHeight)} mm`, 20, 35);
          
          ctx.font = '16px system-ui';
          ctx.fillText(`Right: ${Math.round(rightWidth)}×${Math.round(rightHeight)} mm`, 20, 65);
          ctx.fillText(`Bridge: ${Math.round(bridgeW)} mm`, 20, 95);

          log(`Left: ${Math.round(leftWidth)}×${Math.round(leftHeight)}mm | Right: ${Math.round(rightWidth)}×${Math.round(rightHeight)}mm | Bridge: ${Math.round(bridgeW)}mm`);

          // Store measurements
          state.lastMeasurement = {
            leftWidth: Math.round(leftWidth),
            leftHeight: Math.round(leftHeight),
            rightWidth: Math.round(rightWidth),
            rightHeight: Math.round(rightHeight),
            bridge: Math.round(bridgeW)
          };
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText(`Drag GREEN corners to adjust ${this.activeFrame.toUpperCase()} frame | Toggle to switch frames`, 20, H - 20);

        // Active frame indicator
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 16px system-ui';
        ctx.fillText(`Active: ${this.activeFrame.toUpperCase()} Frame`, W - 200, 30);
      },

      toggleFrame() {
        this.activeFrame = this.activeFrame === 'left' ? 'right' : 'left';
        const btn = document.getElementById('toggle-frame');
        btn.textContent = `Toggle Frame (${this.activeFrame === 'left' ? 'Left' : 'Right'})`;
        log(`Switched to ${this.activeFrame} frame`);
      },

      reset() {
        this.leftFrame = { top: null, bottom: null, left: null, right: null };
        this.rightFrame = { top: null, bottom: null, left: null, right: null };
        this.pixelsPerMm = null;
        this.activeFrame = 'left';
        log('Frame lines reset');
      }
    };

    // ==================== CAMERA & MEDIAPIPE ====================
    async function startCamera() {
      if (state.running) return;
      state.running = true;
      state.photoMode = false;
      state.isStable = false;
      state.stabilityCounter = 0;
      log('Starting camera...');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: W, height: H, facingMode: 'user' } 
        });
        video.srcObject = stream;
        video.style.display = 'block';
        capturedImg.style.display = 'none';

        video.onloadedmetadata = async () => {
          log('Initializing MediaPipe Face Mesh...');
          
          state.faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
          });
          
          state.faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
            selfieMode: true
          });
          
          state.faceMesh.onResults((results) => {
            if (!state.running) return;
            
            if (state.photoMode) {
              // In photo mode, process the captured landmarks
              if (state.capturedLandmarks) {
                if (state.currentTab === 'pupil') {
                  pupilDetector.processPhotoMode(state.capturedLandmarks);
                } else {
                  frameFitter.processPhotoMode(state.capturedLandmarks);
                }
              }
            } else {
              // In live view mode
              if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const lm = results.multiFaceLandmarks[0];
                if (state.currentTab === 'pupil') {
                  pupilDetector.processLiveView(lm);
                } else {
                  frameFitter.processLiveView(lm);
                }
              } else {
                state.stabilityCounter = 0;
                state.isStable = false;
              }
            }
          });

          const processFrame = async () => {
            if (state.running && video.readyState === 4) {
              if (!state.photoMode) {
                await state.faceMesh.send({ image: video });
              }
              state.animationId = requestAnimationFrame(processFrame);
            }
          };
          
          await state.faceMesh.initialize();
          log('System ready! Keep stable for 2 seconds to enable capture');
          processFrame();
        };
      } catch (e) { 
        log('Camera error: ' + e.message); 
        state.running = false;
      }
    }

    function stopCamera() {
      if (!state.running) return;
      state.running = false;
      state.photoMode = false;
      state.isStable = false;
      state.stabilityCounter = 0;
      state.capturedLandmarks = null;
      log('Stopping camera...');
      
      if (state.animationId) {
        cancelAnimationFrame(state.animationId);
        state.animationId = null;
      }
      
      if (state.faceMesh) {
        state.faceMesh.close();
        state.faceMesh = null;
      }
      
      const stream = video.srcObject;
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
      
      ctx.clearRect(0, 0, W, H);
      video.style.display = 'block';
      capturedImg.style.display = 'none';
      
      // Reset buttons
      if (state.currentTab === 'pupil') {
        document.getElementById('capture-photo-pupil').disabled = true;
        document.getElementById('save-pupil').disabled = true;
        const indicator = document.getElementById('pupil-stable');
        indicator.textContent = 'Waiting for stable position...';
        indicator.classList.remove('stable');
      } else {
        document.getElementById('capture-photo-frame').disabled = true;
        document.getElementById('save-frame').disabled = true;
        document.getElementById('toggle-frame').disabled = true;
        const indicator = document.getElementById('frame-stable');
        indicator.textContent = 'Waiting for stable position...';
        indicator.classList.remove('stable');
      }
      
      log('Camera stopped');
    }

    async function capturePhoto() {
      if (!state.running || !state.isStable) {
        log('Wait for stable position before capturing!');
        return;
      }

      log('Capturing photo...');
      
      // Create a canvas to capture current video frame (clean, no overlays)
      const captureCanvas = document.createElement('canvas');
      captureCanvas.width = W;
      captureCanvas.height = H;
      const captureCtx = captureCanvas.getContext('2d');
      captureCtx.drawImage(video, 0, 0, W, H);
      
      // Convert to image
      const imageData = captureCanvas.toDataURL('image/png');
      capturedImg.src = imageData;
      state.capturedImage = imageData;
      
      // Process the image to get landmarks
      const img = new Image();
      img.onload = async () => {
        const results = await new Promise((resolve) => {
          const tempFaceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
          });
          
          tempFaceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
            selfieMode: true
          });
          
          tempFaceMesh.onResults((res) => {
            resolve(res);
            tempFaceMesh.close();
          });
          
          tempFaceMesh.initialize().then(() => {
            tempFaceMesh.send({ image: img });
          });
        });
        
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
          state.capturedLandmarks = results.multiFaceLandmarks[0];
          
          // Switch to photo mode
          state.photoMode = true;
          video.style.display = 'none';
          capturedImg.style.display = 'block';
          
          // Process the captured image
          if (state.currentTab === 'pupil') {
            pupilDetector.processPhotoMode(state.capturedLandmarks);
            document.getElementById('save-pupil').disabled = false;
            document.getElementById('capture-photo-pupil').disabled = false;
            document.getElementById('capture-photo-pupil').textContent = 'Recapture Photo';
          } else {
            frameFitter.processPhotoMode(state.capturedLandmarks);
            document.getElementById('save-frame').disabled = false;
            document.getElementById('toggle-frame').disabled = false;
            document.getElementById('capture-photo-frame').disabled = false;
            document.getElementById('capture-photo-frame').textContent = 'Recapture Photo';
          }
          
          log('Photo captured! Adjust measurements by dragging and click Save Result');
        } else {
          log('Failed to detect face in captured image. Please try again.');
        }
      };
      img.src = imageData;
    }

    function saveResult() {
      if (!state.photoMode || !state.capturedImage) {
        log('Capture a photo first!');
        return;
      }
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = W;
      tempCanvas.height = H;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw captured image
      tempCtx.drawImage(capturedImg, 0, 0, W, H);
      
      // Draw overlay with measurements
      tempCtx.drawImage(canvas, 0, 0);
      
      // Add measurement text overlay
      tempCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      tempCtx.fillRect(0, H - 120, W, 120);
      
      tempCtx.fillStyle = '#ffffff';
      tempCtx.font = 'bold 18px system-ui';
      
      if (state.currentTab === 'pupil' && state.lastMeasurement) {
        const m = state.lastMeasurement;
        tempCtx.fillText(`Pupillary Distance (PD): ${m.pd} mm`, 20, H - 90);
        tempCtx.fillText(`Left Eye to Nose: ${m.leftNose} mm | Right Eye to Nose: ${m.rightNose} mm`, 20, H - 65);
        tempCtx.fillText(`Head Tilt: ${m.tilt}° | Estimated Distance: ${m.distance} mm`, 20, H - 40);
        tempCtx.font = '14px system-ui';
        tempCtx.fillText(`Timestamp: ${new Date().toLocaleString()}`, 20, H - 15);
      } else if (state.currentTab === 'frame' && state.lastMeasurement) {
        const m = state.lastMeasurement;
        tempCtx.fillText(`Left Frame: ${m.leftWidth} × ${m.leftHeight} mm | Right Frame: ${m.rightWidth} × ${m.rightHeight} mm`, 20, H - 90);
        tempCtx.fillText(`Bridge Width: ${m.bridge} mm`, 20, H - 65);
        tempCtx.font = '14px system-ui';
        tempCtx.fillText(`Timestamp: ${new Date().toLocaleString()}`, 20, H - 40);
      }
      
      tempCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${state.currentTab}_measurement_${Date.now()}.png`;
        a.click();
        URL.revokeObjectURL(url);
        log(`✓ Saved: ${a.download}`);
      });
    }

    // ==================== MOUSE EVENTS ====================
    canvas.addEventListener('mousedown', (e) => {
      if (!state.photoMode) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (W / rect.width);
      const y = (e.clientY - rect.top) * (H / rect.height);

      if (state.currentTab === 'pupil') {
        const autoLeft = [state.capturedLandmarks[468].x * W, state.capturedLandmarks[468].y * H];
        const autoRight = [state.capturedLandmarks[473].x * W, state.capturedLandmarks[473].y * H];
        const finalLeft = pupilDetector.manualLeftPupil || autoLeft;
        const finalRight = pupilDetector.manualRightPupil || autoRight;
        
        if (pupilDetector.dist([x, y], finalLeft) < 30) {
          pupilDetector.selectedEye = 'left';
          pupilDetector.manualLeftPupil = [...finalLeft];
          pupilDetector.isDragging = true;
        } else if (pupilDetector.dist([x, y], finalRight) < 30) {
          pupilDetector.selectedEye = 'right';
          pupilDetector.manualRightPupil = [...finalRight];
          pupilDetector.isDragging = true;
        }
      } else {
        // Check BOTH frames for dragging (not just active frame)
        if (!frameFitter.leftFrame.top) return;
        
        // Check left frame handles
        const leftHandles = [
          { name: 'left-top-left', frame: 'left', pos: [frameFitter.leftFrame.top.x1, frameFitter.leftFrame.top.y1] },
          { name: 'left-top-right', frame: 'left', pos: [frameFitter.leftFrame.top.x2, frameFitter.leftFrame.top.y2] },
          { name: 'left-bottom-left', frame: 'left', pos: [frameFitter.leftFrame.bottom.x1, frameFitter.leftFrame.bottom.y1] },
          { name: 'left-bottom-right', frame: 'left', pos: [frameFitter.leftFrame.bottom.x2, frameFitter.leftFrame.bottom.y2] }
        ];
        
        // Check right frame handles
        const rightHandles = [
          { name: 'right-top-left', frame: 'right', pos: [frameFitter.rightFrame.top.x1, frameFitter.rightFrame.top.y1] },
          { name: 'right-top-right', frame: 'right', pos: [frameFitter.rightFrame.top.x2, frameFitter.rightFrame.top.y2] },
          { name: 'right-bottom-left', frame: 'right', pos: [frameFitter.rightFrame.bottom.x1, frameFitter.rightFrame.bottom.y1] },
          { name: 'right-bottom-right', frame: 'right', pos: [frameFitter.rightFrame.bottom.x2, frameFitter.rightFrame.bottom.y2] }
        ];

        const allHandles = [...leftHandles, ...rightHandles];

        for (const h of allHandles) {
          if (frameFitter.dist([x, y], h.pos) < 20) {
            frameFitter.dragging = h.name;
            frameFitter.activeFrame = h.frame; // Switch to that frame when dragging
            frameFitter.dragOffset = [x - h.pos[0], y - h.pos[1]];
            
            // Update button text
            const btn = document.getElementById('toggle-frame');
            btn.textContent = `Toggle Frame (${frameFitter.activeFrame === 'left' ? 'Left' : 'Right'})`;
            break;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!state.photoMode) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (W / rect.width);
      const y = (e.clientY - rect.top) * (H / rect.height);

      if (state.currentTab === 'pupil' && pupilDetector.isDragging) {
        if (pupilDetector.selectedEye === 'left') {
          pupilDetector.manualLeftPupil = [x, y];
        } else if (pupilDetector.selectedEye === 'right') {
          pupilDetector.manualRightPupil = [x, y];
        }
        
        // Redraw with new position
        pupilDetector.processPhotoMode(state.capturedLandmarks);
        
      } else if (state.currentTab === 'frame' && frameFitter.dragging) {
        // Determine which frame is being dragged based on handle name
        const isDraggingLeft = frameFitter.dragging.startsWith('left-');
        const currentFrame = isDraggingLeft ? frameFitter.leftFrame : frameFitter.rightFrame;
        const handleType = frameFitter.dragging.split('-').slice(-2).join('-'); // e.g., "top-left"
        
        const nx = x - frameFitter.dragOffset[0];
        const ny = y - frameFitter.dragOffset[1];

        switch (handleType) {
          case 'top-left':
            currentFrame.top.x1 = nx;
            currentFrame.top.y1 = ny;
            currentFrame.left.x1 = nx;
            currentFrame.left.y1 = ny;
            currentFrame.bottom.x1 = nx;
            break;
          case 'top-right':
            currentFrame.top.x2 = nx;
            currentFrame.top.y2 = ny;
            currentFrame.right.x1 = nx;
            currentFrame.right.y1 = ny;
            currentFrame.bottom.x2 = nx;
            break;
          case 'bottom-left':
            currentFrame.bottom.x1 = nx;
            currentFrame.bottom.y1 = ny;
            currentFrame.left.x2 = nx;
            currentFrame.left.y2 = ny;
            currentFrame.top.x1 = nx;
            break;
          case 'bottom-right':
            currentFrame.bottom.x2 = nx;
            currentFrame.bottom.y2 = ny;
            currentFrame.right.x2 = nx;
            currentFrame.right.y2 = ny;
            currentFrame.top.x2 = nx;
            break;
        }
        
        // Redraw with new position
        frameFitter.processPhotoMode(state.capturedLandmarks);
      }
    });

    canvas.addEventListener('mouseup', () => {
      pupilDetector.selectedEye = null;
      pupilDetector.isDragging = false;
      frameFitter.dragging = null;
    });

    // Touch events for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      canvas.dispatchEvent(new MouseEvent('mouseup'));
    });

    // ==================== BUTTON EVENTS ====================
    document.getElementById('start-pupil').addEventListener('click', () => {
      state.currentTab = 'pupil';
      pupilDetector.reset();
      startCamera();
    });

    document.getElementById('stop-pupil').addEventListener('click', stopCamera);

    document.getElementById('capture-photo-pupil').addEventListener('click', () => {
      if (state.photoMode) {
        // Recapture - restart camera
        pupilDetector.reset();
        state.photoMode = false;
        state.capturedLandmarks = null;
        document.getElementById('capture-photo-pupil').textContent = 'Capture Photo';
        document.getElementById('save-pupil').disabled = true;
        video.style.display = 'block';
        capturedImg.style.display = 'none';
        log('Restarting camera for new capture...');
      } else {
        capturePhoto();
      }
    });

    document.getElementById('reset-auto').addEventListener('click', () => {
      pupilDetector.reset();
      log('Reset manual adjustments');
      
      if (state.photoMode && state.capturedLandmarks) {
        pupilDetector.processPhotoMode(state.capturedLandmarks);
      }
    });

    document.getElementById('save-pupil').addEventListener('click', saveResult);

    document.getElementById('start-frame').addEventListener('click', () => {
      state.currentTab = 'frame';
      frameFitter.reset();
      startCamera();
    });

    document.getElementById('stop-frame').addEventListener('click', stopCamera);

    document.getElementById('capture-photo-frame').addEventListener('click', () => {
      if (state.photoMode) {
        // Recapture - restart camera
        frameFitter.reset();
        state.photoMode = false;
        state.capturedLandmarks = null;
        document.getElementById('capture-photo-frame').textContent = 'Capture Photo';
        document.getElementById('save-frame').disabled = true;
        document.getElementById('toggle-frame').disabled = true;
        video.style.display = 'block';
        capturedImg.style.display = 'none';
        log('Restarting camera for new capture...');
      } else {
        capturePhoto();
      }
    });

    document.getElementById('toggle-frame').addEventListener('click', () => {
      frameFitter.toggleFrame();
      
      if (state.photoMode && state.capturedLandmarks) {
        frameFitter.processPhotoMode(state.capturedLandmarks);
      }
    });

    document.getElementById('reset-frame').addEventListener('click', () => {
      frameFitter.reset();
      
      if (state.photoMode && state.capturedLandmarks) {
        frameFitter.processPhotoMode(state.capturedLandmarks);
      } else {
        log('Frame lines will be reset on next capture');
      }
    });

    document.getElementById('save-frame').addEventListener('click', saveResult);

    // ==================== KEYBOARD SHORTCUTS ====================
    document.addEventListener('keydown', (e) => {
      if (!state.running) return;

      if (state.currentTab === 'pupil' && state.photoMode) {
        switch (e.key.toLowerCase()) {
          case 'r':
            pupilDetector.reset();
            log('Reset manual adjustments');
            if (state.capturedLandmarks) {
              pupilDetector.processPhotoMode(state.capturedLandmarks);
            }
            break;
        }
      }
      
      if (e.key === 'Escape') {
        stopCamera();
      }
    });

    log('OptiFocus ready. Select a tab and start camera.');
  </script>
</body>
</html>